import React, { useState, useEffect, useRef } from 'react';
import { LineChart, Line, BarChart, Bar, PieChart, Pie, Cell, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, ScatterChart, Scatter, RadarChart, PolarGrid, PolarAngleAxis, PolarRadiusAxis, Radar, Area, AreaChart } from 'recharts';
import { Camera, Download, Upload, Save, Share2, TrendingUp, AlertCircle, CheckCircle, Settings, Database, Zap, Eye, BarChart3, MessageSquare, Sparkles, Play, X, Layers, Box, Activity, FileText, Calculator } from 'lucide-react';

// Extended materials database
const MATERIALS_DATABASE = [
  { id: 'steel_s275', name: { en: 'Steel S275', cs: 'Ocel S275', sk: 'Oceľ S275', de: 'Stahl S275', fr: 'Acier S275', es: 'Acero S275', it: 'Acciaio S275', pl: 'Stal S275', ru: 'Сталь S275', uk: 'Сталь S275', zh: '钢材 S275', ja: '鋼材 S275', ko: '강철 S275', ar: 'فولاذ S275', tr: 'Çelik S275', nl: 'Staal S275', sv: 'Stål S275', no: 'Stål S275', da: 'Stål S275', fi: 'Teräs S275', pt: 'Aço S275', ro: 'Oțel S275' }, type: 'Metal', density: 7850, youngModulus: 210, tensileStrength: 410, hardness: 140 },
  { id: 'steel_s355', name: { en: 'Steel S355', cs: 'Ocel S355', sk: 'Oceľ S355', de: 'Stahl S355', fr: 'Acier S355', es: 'Acero S355', it: 'Acciaio S355', pl: 'Stal S355', ru: 'Сталь S355', uk: 'Сталь S355', zh: '钢材 S355', ja: '鋼材 S355', ko: '강철 S355', ar: 'فولاذ S355', tr: 'Çelik S355', nl: 'Staal S355', sv: 'Stål S355', no: 'Stål S355', da: 'Stål S355', fi: 'Teräs S355', pt: 'Aço S355', ro: 'Oțel S355' }, type: 'Metal', density: 7850, youngModulus: 210, tensileStrength: 510, hardness: 160 },
  { id: 'stainless_304', name: { en: 'Stainless 304', cs: 'Nerez 304', sk: 'Nehrdzavejúca 304', de: 'Edelstahl 304', fr: 'Inox 304', es: 'Inoxidable 304', it: 'Inox 304', pl: 'Nierdzewna 304', ru: 'Нержавейка 304', uk: 'Нержавійка 304', zh: '不锈钢 304', ja: 'ステンレス 304', ko: '스테인리스 304', ar: 'ستانلس 304', tr: 'Paslanmaz 304', nl: 'RVS 304', sv: 'Rostfritt 304', no: 'Rustfritt 304', da: 'Rustfrit 304', fi: 'Ruostumaton 304', pt: 'Inox 304', ro: 'Inox 304' }, type: 'Metal', density: 8000, youngModulus: 193, tensileStrength: 515, hardness: 170 },
  { id: 'al_6061', name: { en: 'Aluminum 6061', cs: 'Hliník 6061', sk: 'Hliník 6061', de: 'Aluminium 6061', fr: 'Aluminium 6061', es: 'Aluminio 6061', it: 'Alluminio 6061', pl: 'Aluminium 6061', ru: 'Алюминий 6061', uk: 'Алюміній 6061', zh: '铝 6061', ja: 'アルミニウム 6061', ko: '알루미늄 6061', ar: 'ألومنيوم 6061', tr: 'Alüminyum 6061', nl: 'Aluminium 6061', sv: 'Aluminium 6061', no: 'Aluminium 6061', da: 'Aluminium 6061', fi: 'Alumiini 6061', pt: 'Alumínio 6061', ro: 'Aluminiu 6061' }, type: 'Metal', density: 2700, youngModulus: 69, tensileStrength: 310, hardness: 95 },
  { id: 'ti_grade5', name: { en: 'Titanium Grade 5', cs: 'Titan Grade 5', sk: 'Titán Grade 5', de: 'Titan Grade 5', fr: 'Titane Grade 5', es: 'Titanio Grade 5', it: 'Titanio Grade 5', pl: 'Tytan Grade 5', ru: 'Титан Grade 5', uk: 'Титан Grade 5', zh: '钛 Grade 5', ja: 'チタン Grade 5', ko: '티타늄 Grade 5', ar: 'تيتانيوم Grade 5', tr: 'Titanyum Grade 5', nl: 'Titanium Grade 5', sv: 'Titan Grade 5', no: 'Titan Grade 5', da: 'Titan Grade 5', fi: 'Titaani Grade 5', pt: 'Titânio Grade 5', ro: 'Titan Grade 5' }, type: 'Metal', density: 4430, youngModulus: 114, tensileStrength: 950, hardness: 340 },
  { id: 'brass', name: { en: 'Brass', cs: 'Mosaz', sk: 'Mosadz', de: 'Messing', fr: 'Laiton', es: 'Latón', it: 'Ottone', pl: 'Mosiądz', ru: 'Латунь', uk: 'Латунь', zh: '黄铜', ja: '真鍮', ko: '황동', ar: 'نحاس أصفر', tr: 'Pirinç', nl: 'Messing', sv: 'Mässing', no: 'Messing', da: 'Messing', fi: 'Messinki', pt: 'Latão', ro: 'Alamă' }, type: 'Metal', density: 8500, youngModulus: 97, tensileStrength: 340, hardness: 100 },
  { id: 'copper', name: { en: 'Copper', cs: 'Měď', sk: 'Meď', de: 'Kupfer', fr: 'Cuivre', es: 'Cobre', it: 'Rame', pl: 'Miedź', ru: 'Медь', uk: 'Мідь', zh: '铜', ja: '銅', ko: '구리', ar: 'نحاس', tr: 'Bakır', nl: 'Koper', sv: 'Koppar', no: 'Kobber', da: 'Kobber', fi: 'Kupari', pt: 'Cobre', ro: 'Cupru' }, type: 'Metal', density: 8940, youngModulus: 117, tensileStrength: 220, hardness: 45 },
  { id: 'glass', name: { en: 'Glass', cs: 'Sklo', sk: 'Sklo', de: 'Glas', fr: 'Verre', es: 'Vidrio', it: 'Vetro', pl: 'Szkło', ru: 'Стекло', uk: 'Скло', zh: '玻璃', ja: 'ガラス', ko: '유리', ar: 'زجاج', tr: 'Cam', nl: 'Glas', sv: 'Glas', no: 'Glass', da: 'Glas', fi: 'Lasi', pt: 'Vidro', ro: 'Sticlă' }, type: 'Non-Metal', density: 2500, youngModulus: 70, tensileStrength: 50, hardness: 600 },
  { id: 'granite', name: { en: 'Granite', cs: 'Žula', sk: 'Žula', de: 'Granit', fr: 'Granit', es: 'Granito', it: 'Granito', pl: 'Granit', ru: 'Гранит', uk: 'Граніт', zh: '花岗岩', ja: '花崗岩', ko: '화강암', ar: 'جرانيت', tr: 'Granit', nl: 'Graniet', sv: 'Granit', no: 'Granitt', da: 'Granit', fi: 'Graniitti', pt: 'Granito', ro: 'Granit' }, type: 'Stone', density: 2750, youngModulus: 50, tensileStrength: 20, hardness: 200 }
];

const TRANSLATIONS = {
  en: { appTitle: 'AWJ Professional Calculator', level: 'Level', language: 'Language', background: 'Background', student: 'Student', engineer: 'Engineer', manager: 'Manager', cutTime: 'Cut Time', costPerPart: 'Cost/Part', avgRoughness: 'Avg. Roughness', maxTaper: 'Max. Taper', productivity: 'Productivity', inputsConfig: 'Inputs & Configuration', materialGeometry: 'Material & Geometry', material: 'Material', thickness: 'Thickness (mm)', cutLength: 'Cut Length (mm)', machineTooling: 'Machine & Tooling', pressure: 'Pump Pressure (MPa)', orificeId: 'Orifice ID (mm)', nozzleId: 'Nozzle ID (mm)', abrasiveType: 'Abrasive Type', abrasiveFlow: 'Abrasive Flow (g/min)', electricityCost: 'Electricity Cost (€/kWh)', optimizationGoal: 'Optimization Goal', tradeoff: 'Trade-off: Speed vs. Quality', eco: 'Eco', quality: 'Quality', predictionModel: 'Prediction Model', modelPhysical: 'Physical Model', modelRegression: 'Regression Model', modelAnn: 'Neural Network', modelGP: 'Gaussian Process', modelSymbolic: 'Symbolic Regression', modelHybrid: 'Hybrid Model', recommendedParams: 'Recommended Parameters', traverseSpeed: 'Traverse Speed', limitDepth: 'Limit Depth', visualizations: 'Visualizations', chartRoughness: 'Roughness vs Depth', chartTaper: 'Taper vs Depth', chartForces: 'Force Analysis', chartStress: 'Stress-Strain', analysis: 'Analysis & Export', costBreakdown: 'Cost Breakdown', comparison: 'Material Comparison', compareWith: 'Compare with', modelDetails: 'Model Details', vrSimulation: 'VR/AR Simulation', aiAssistant: 'AI Assistant', export: 'Export Results', saveProject: 'Save Project', expertAnalysis: 'Expert Analysis', generateAnalysis: 'Generate Analysis', cutSimulation: 'Cut Simulation', paramAnalysis: 'Parameter Analysis', dataViz: 'Data Visualization', discreteResults: 'Discrete Results at Cut Depth', depth: 'Depth', garnet: 'Garnet', olivine: 'Olivine' },
  cs: { appTitle: 'AWJ Profesionální Kalkulátor', level: 'Úroveň', language: 'Jazyk', background: 'Pozadí', student: 'Student', engineer: 'Inženýr', manager: 'Manažer', cutTime: 'Čas řezu', costPerPart: 'Náklady/díl', avgRoughness: 'Prům. Drsnost', maxTaper: 'Max. Kuželovitost', productivity: 'Produktivita', inputsConfig: 'Vstupy a Konfigurace', materialGeometry: 'Materiál & Geometrie', material: 'Materiál', thickness: 'Tloušťka (mm)', cutLength: 'Délka řezu (mm)', machineTooling: 'Stroj & Nástroje', pressure: 'Tlak čerpadla (MPa)', orificeId: 'Průměr orifice (mm)', nozzleId: 'Průměr trysky (mm)', abrasiveType: 'Typ abraziva', abrasiveFlow: 'Průtok abraziva (g/min)', electricityCost: 'Cena el. energie (€/kWh)', optimizationGoal: 'Cíl Optimalizace', tradeoff: 'Kompromis: Rychlost vs. Kvalita', eco: 'Eko', quality: 'Kvalita', predictionModel: 'Predikční Model', modelPhysical: 'Fyzikální Model', modelRegression: 'Regresní Model', modelAnn: 'Neuronová Síť', modelGP: 'Gaussovský Proces', modelSymbolic: 'Symbolická Regrese', modelHybrid: 'Hybridní Model', recommendedParams: 'Doporučené Parametry', traverseSpeed: 'Rychlost Posuvu', limitDepth: 'Mezní Hloubka', visualizations: 'Vizualizace', chartRoughness: 'Drsnost vs. Hloubka', chartTaper: 'Kuželovitost vs. Hloubka', chartForces: 'Analýza Sil', chartStress: 'Napětí-Deformace', analysis: 'Analýza a Export', costBreakdown: 'Rozpad Nákladů', comparison: 'Srovnání Materiálů', compareWith: 'Porovnat s', modelDetails: 'Detaily Modelu', vrSimulation: 'VR/AR Simulace', aiAssistant: 'AI Asistent', export: 'Exportovat', saveProject: 'Uložit Projekt', expertAnalysis: 'Expertní Analýza', generateAnalysis: 'Vygenerovat Analýzu', cutSimulation: 'Simulace Řezání', paramAnalysis: 'Analýza Parametrů', dataViz: 'Vizualizace Dat', discreteResults: 'Diskrétní Výsledky', depth: 'Hloubka', garnet: 'Granát', olivine: 'Olivín' },
  sk: { appTitle: 'AWJ Profesionálny Kalkulátor', level: 'Úroveň', language: 'Jazyk', background: 'Pozadie', student: 'Študent', engineer: 'Inžinier', manager: 'Manažér', cutTime: 'Čas rezu', costPerPart: 'Náklady/diel', avgRoughness: 'Priem. Drsnosť', maxTaper: 'Max. Kužeľovitosť', productivity: 'Produktivita', inputsConfig: 'Vstupy a Konfigurácia', materialGeometry: 'Materiál & Geometria', material: 'Materiál', thickness: 'Hrúbka (mm)', cutLength: 'Dĺžka rezu (mm)', machineTooling: 'Stroj & Nástroje', pressure: 'Tlak čerpadla (MPa)', orificeId: 'Priemer orifice (mm)', nozzleId: 'Priemer trysky (mm)', abrasiveType: 'Typ abrazíva', abrasiveFlow: 'Prietok abrazíva (g/min)', electricityCost: 'Cena el. energie (€/kWh)', optimizationGoal: 'Cieľ Optimalizácie', tradeoff: 'Kompromis: Rýchlosť vs. Kvalita', eco: 'Eko', quality: 'Kvalita', predictionModel: 'Predikčný Model', modelPhysical: 'Fyzikálny Model', modelRegression: 'Regresný Model', modelAnn: 'Neurónová Sieť', modelGP: 'Gaussovský Proces', modelSymbolic: 'Symbolická Regresia', modelHybrid: 'Hybridný Model', recommendedParams: 'Odporúčané Parametre', traverseSpeed: 'Rýchlosť Posuvu', limitDepth: 'Limitná Hĺbka', visualizations: 'Vizualizácie', chartRoughness: 'Drsnosť vs. Hĺbka', chartTaper: 'Kužeľovitosť vs. Hĺbka', chartForces: 'Analýza Síl', chartStress: 'Napätie-Deformácia', analysis: 'Analýza a Export', costBreakdown: 'Rozpad Nákladov', comparison: 'Porovnanie Materiálov', compareWith: 'Porovnať s', modelDetails: 'Detaily Modelu', vrSimulation: 'VR/AR Simulácia', aiAssistant: 'AI Asistent', export: 'Exportovať', saveProject: 'Uložiť Projekt', expertAnalysis: 'Expertná Analýza', generateAnalysis: 'Vygenerovať Analýzu', cutSimulation: 'Simulácia Rezania', paramAnalysis: 'Analýza Parametrov', dataViz: 'Vizualizácia Dát', discreteResults: 'Diskrétne Výsledky', depth: 'Hĺbka', garnet: 'Granát', olivine: 'Olivín' },
  de: { appTitle: 'AWJ Professioneller Rechner', level: 'Stufe', language: 'Sprache', background: 'Hintergrund', student: 'Student', engineer: 'Ingenieur', manager: 'Manager', cutTime: 'Schnittzeit', costPerPart: 'Kosten/Teil', avgRoughness: 'Durchschn. Rauheit', maxTaper: 'Max. Verjüngung', productivity: 'Produktivität', inputsConfig: 'Eingaben & Konfiguration', materialGeometry: 'Material & Geometrie', material: 'Material', thickness: 'Dicke (mm)', cutLength: 'Schnittlänge (mm)', machineTooling: 'Maschine & Werkzeuge', pressure: 'Pumpendruck (MPa)', orificeId: 'Düsen-ID (mm)', nozzleId: 'Düsen-ID (mm)', abrasiveType: 'Abrasivtyp', abrasiveFlow: 'Abrasivfluss (g/min)', electricityCost: 'Stromkosten (€/kWh)', optimizationGoal: 'Optimierungsziel', tradeoff: 'Abwägung: Geschwindigkeit vs. Qualität', eco: 'Öko', quality: 'Qualität', predictionModel: 'Vorhersagemodell', modelPhysical: 'Physikalisches Modell', modelRegression: 'Regressionsmodell', modelAnn: 'Neuronales Netz', modelGP: 'Gaußscher Prozess', modelSymbolic: 'Symbolische Regression', modelHybrid: 'Hybridmodell', recommendedParams: 'Empfohlene Parameter', traverseSpeed: 'Vorschubgeschwindigkeit', limitDepth: 'Grenztiefe', visualizations: 'Visualisierungen', chartRoughness: 'Rauheit vs. Tiefe', chartTaper: 'Verjüngung vs. Tiefe', chartForces: 'Kraftanalyse', chartStress: 'Spannung-Dehnung', analysis: 'Analyse & Export', costBreakdown: 'Kostenaufschlüsselung', comparison: 'Materialvergleich', compareWith: 'Vergleichen mit', modelDetails: 'Modelldetails', vrSimulation: 'VR/AR-Simulation', aiAssistant: 'KI-Assistent', export: 'Exportieren', saveProject: 'Projekt speichern', expertAnalysis: 'Expertenanalyse', generateAnalysis: 'Analyse generieren', cutSimulation: 'Schnittsimulation', paramAnalysis: 'Parameteranalyse', dataViz: 'Datenvisualisierung', discreteResults: 'Diskrete Ergebnisse', depth: 'Tiefe', garnet: 'Granat', olivine: 'Olivin' },
  fr: { appTitle: 'Calculateur AWJ Professionnel', level: 'Niveau', language: 'Langue', background: 'Arrière-plan', student: 'Étudiant', engineer: 'Ingénieur', manager: 'Gestionnaire', cutTime: 'Temps de coupe', costPerPart: 'Coût/Pièce', avgRoughness: 'Rugosité moy.', maxTaper: 'Conicité max.', productivity: 'Productivité', inputsConfig: 'Entrées et Configuration', materialGeometry: 'Matériau & Géométrie', material: 'Matériau', thickness: 'Épaisseur (mm)', cutLength: 'Longueur de coupe (mm)', machineTooling: 'Machine & Outillage', pressure: 'Pression pompe (MPa)', orificeId: 'Diamètre orifice (mm)', nozzleId: 'Diamètre buse (mm)', abrasiveType: 'Type d\'abrasif', abrasiveFlow: 'Débit abrasif (g/min)', electricityCost: 'Coût électricité (€/kWh)', optimizationGoal: 'Objectif d\'optimisation', tradeoff: 'Compromis: Vitesse vs. Qualité', eco: 'Éco', quality: 'Qualité', predictionModel: 'Modèle de prédiction', modelPhysical: 'Modèle physique', modelRegression: 'Modèle de régression', modelAnn: 'Réseau neuronal', modelGP: 'Processus gaussien', modelSymbolic: 'Régression symbolique', modelHybrid: 'Modèle hybride', recommendedParams: 'Paramètres recommandés', traverseSpeed: 'Vitesse de traverse', limitDepth: 'Profondeur limite', visualizations: 'Visualisations', chartRoughness: 'Rugosité vs. Profondeur', chartTaper: 'Conicité vs. Profondeur', chartForces: 'Analyse des forces', chartStress: 'Contrainte-Déformation', analysis: 'Analyse & Export', costBreakdown: 'Répartition des coûts', comparison: 'Comparaison matériaux', compareWith: 'Comparer avec', modelDetails: 'Détails du modèle', vrSimulation: 'Simulation VR/AR', aiAssistant: 'Assistant IA', export: 'Exporter', saveProject: 'Sauvegarder projet', expertAnalysis: 'Analyse experte', generateAnalysis: 'Générer analyse', cutSimulation: 'Simulation de coupe', paramAnalysis: 'Analyse paramètres', dataViz: 'Visualisation données', discreteResults: 'Résultats discrets', depth: 'Profondeur', garnet: 'Grenat', olivine: 'Olivine' },
  es: { appTitle: 'Calculadora AWJ Profesional', level: 'Nivel', language: 'Idioma', background: 'Fondo', student: 'Estudiante', engineer: 'Ingeniero', manager: 'Gerente', cutTime: 'Tiempo de corte', costPerPart: 'Costo/Pieza', avgRoughness: 'Rugosidad prom.', maxTaper: 'Conicidad máx.', productivity: 'Productividad', inputsConfig: 'Entradas y Configuración', materialGeometry: 'Material y Geometría', material: 'Material', thickness: 'Espesor (mm)', cutLength: 'Longitud de corte (mm)', machineTooling: 'Máquina y Herramientas', pressure: 'Presión bomba (MPa)', orificeId: 'Diámetro orificio (mm)', nozzleId: 'Diámetro boquilla (mm)', abrasiveType: 'Tipo de abrasivo', abrasiveFlow: 'Flujo abrasivo (g/min)', electricityCost: 'Costo electricidad (€/kWh)', optimizationGoal: 'Objetivo de optimización', tradeoff: 'Equilibrio: Velocidad vs. Calidad', eco: 'Eco', quality: 'Calidad', predictionModel: 'Modelo de predicción', modelPhysical: 'Modelo físico', modelRegression: 'Modelo de regresión', modelAnn: 'Red neuronal', modelGP: 'Proceso gaussiano', modelSymbolic: 'Regresión simbólica', modelHybrid: 'Modelo híbrido', recommendedParams: 'Parámetros recomendados', traverseSpeed: 'Velocidad de avance', limitDepth: 'Profundidad límite', visualizations: 'Visualizaciones', chartRoughness: 'Rugosidad vs. Profundidad', chartTaper: 'Conicidad vs. Profundidad', chartForces: 'Análisis de fuerzas', chartStress: 'Tensión-Deformación', analysis: 'Análisis y Exportación', costBreakdown: 'Desglose de costos', comparison: 'Comparación materiales', compareWith: 'Comparar con', modelDetails: 'Detalles del modelo', vrSimulation: 'Simulación VR/AR', aiAssistant: 'Asistente IA', export: 'Exportar', saveProject: 'Guardar proyecto', expertAnalysis: 'Análisis experto', generateAnalysis: 'Generar análisis', cutSimulation: 'Simulación de corte', paramAnalysis: 'Análisis parámetros', dataViz: 'Visualización datos', discreteResults: 'Resultados discretos', depth: 'Profundidad', garnet: 'Granate', olivine: 'Olivino' },
  it: { appTitle: 'Calcolatore AWJ Professionale', level: 'Livello', language: 'Lingua', background: 'Sfondo', student: 'Studente', engineer: 'Ingegnere', manager: 'Manager', cutTime: 'Tempo di taglio', costPerPart: 'Costo/Pezzo', avgRoughness: 'Rugosità media', maxTaper: 'Conicità max', productivity: 'Produttività', inputsConfig: 'Input e Configurazione', materialGeometry: 'Materiale e Geometria', material: 'Materiale', thickness: 'Spessore (mm)', cutLength: 'Lunghezza taglio (mm)', machineTooling: 'Macchina e Utensili', pressure: 'Pressione pompa (MPa)', orificeId: 'Diametro orifizio (mm)', nozzleId: 'Diametro ugello (mm)', abrasiveType: 'Tipo di abrasivo', abrasiveFlow: 'Flusso abrasivo (g/min)', electricityCost: 'Costo elettricità (€/kWh)', optimizationGoal: 'Obiettivo ottimizzazione', tradeoff: 'Compromesso: Velocità vs. Qualità', eco: 'Eco', quality: 'Qualità', predictionModel: 'Modello predittivo', modelPhysical: 'Modello fisico', modelRegression: 'Modello regressione', modelAnn: 'Rete neurale', modelGP: 'Processo gaussiano', modelSymbolic: 'Regressione simbolica', modelHybrid: 'Modello ibrido', recommendedParams: 'Parametri consigliati', traverseSpeed: 'Velocità avanzamento', limitDepth: 'Profondità limite', visualizations: 'Visualizzazioni', chartRoughness: 'Rugosità vs. Profondità', chartTaper: 'Conicità vs. Profondità', chartForces: 'Analisi forze', chartStress: 'Tensione-Deformazione', analysis: 'Analisi ed Export', costBreakdown: 'Ripartizione costi', comparison: 'Confronto materiali', compareWith: 'Confronta con', modelDetails: 'Dettagli modello', vrSimulation: 'Simulazione VR/AR', aiAssistant: 'Assistente IA', export: 'Esporta', saveProject: 'Salva progetto', expertAnalysis: 'Analisi esperta', generateAnalysis: 'Genera analisi', cutSimulation: 'Simulazione taglio', paramAnalysis: 'Analisi parametri', dataViz: 'Visualizzazione dati', discreteResults: 'Risultati discreti', depth: 'Profondità', garnet: 'Granato', olivine: 'Olivina' },
  pl: { appTitle: 'Kalkulator AWJ Profesjonalny', level: 'Poziom', language: 'Język', background: 'Tło', student: 'Student', engineer: 'Inżynier', manager: 'Menedżer', cutTime: 'Czas cięcia', costPerPart: 'Koszt/Część', avgRoughness: 'Śr. Chropowatość', maxTaper: 'Maks. Stożkowość', productivity: 'Produktywność', inputsConfig: 'Wejścia i Konfiguracja', materialGeometry: 'Materiał i Geometria', material: 'Materiał', thickness: 'Grubość (mm)', cutLength: 'Długość cięcia (mm)', machineTooling: 'Maszyna i Narzędzia', pressure: 'Ciśnienie pompy (MPa)', orificeId: 'Średnica otworu (mm)', nozzleId: 'Średnica dyszy (mm)', abrasiveType: 'Typ ścierniwa', abrasiveFlow: 'Przepływ ścierniwa (g/min)', electricityCost: 'Koszt energii (€/kWh)', optimizationGoal: 'Cel optymalizacji', tradeoff: 'Kompromis: Szybkość vs. Jakość', eco: 'Eko', quality: 'Jakość', predictionModel: 'Model predykcyjny', modelPhysical: 'Model fizyczny', modelRegression: 'Model regresji', modelAnn: 'Sieć neuronowa', modelGP: 'Proces gaussowski', modelSymbolic: 'Regresja symboliczna', modelHybrid: 'Model hybrydowy', recommendedParams: 'Zalecane parametry', traverseSpeed: 'Prędkość posuwu', limitDepth: 'Głębokość graniczna', visualizations: 'Wizualizacje', chartRoughness: 'Chropowatość vs. Głębokość', chartTaper: 'Stożkowość vs. Głębokość', chartForces: 'Analiza sił', chartStress: 'Naprężenie-Odkształcenie', analysis: 'Analiza i Eksport', costBreakdown: 'Podział kosztów', comparison: 'Porównanie materiałów', compareWith: 'Porównaj z', modelDetails: 'Szczegóły modelu', vrSimulation: 'Symulacja VR/AR', aiAssistant: 'Asystent AI', export: 'Eksportuj', saveProject: 'Zapisz projekt', expertAnalysis: 'Analiza ekspercka', generateAnalysis: 'Generuj analizę', cutSimulation: 'Symulacja cięcia', paramAnalysis: 'Analiza parametrów', dataViz: 'Wizualizacja danych', discreteResults: 'Wyniki dyskretne', depth: 'Głębokość', garnet: 'Granat', olivine: 'Oliwin' },
  ru: { appTitle: 'Профессиональный калькулятор AWJ', level: 'Уровень', language: 'Язык', background: 'Фон', student: 'Студент', engineer: 'Инженер', manager: 'Менеджер', cutTime: 'Время резки', costPerPart: 'Стоимость/Деталь', avgRoughness: 'Ср. Шероховатость', maxTaper: 'Макс. Конусность', productivity: 'Производительность', inputsConfig: 'Входы и Конфигурация', materialGeometry: 'Материал и Геометрия', material: 'Материал', thickness: 'Толщина (мм)', cutLength: 'Длина реза (мм)', machineTooling: 'Станок и Инструменты', pressure: 'Давление насоса (МПа)', orificeId: 'Диаметр отверстия (мм)', nozzleId: 'Диаметр сопла (мм)', abrasiveType: 'Тип абразива', abrasiveFlow: 'Расход абразива (г/мин)', electricityCost: 'Стоимость электричества (€/кВтч)', optimizationGoal: 'Цель оптимизации', tradeoff: 'Компромисс: Скорость vs. Качество', eco: 'Эко', quality: 'Качество', predictionModel: 'Прогнозная модель', modelPhysical: 'Физическая модель', modelRegression: 'Регрессионная модель', modelAnn: 'Нейронная сеть', modelGP: 'Гауссовский процесс', modelSymbolic: 'Символическая регрессия', modelHybrid: 'Гибридная модель', recommendedParams: 'Рекомендуемые параметры', traverseSpeed: 'Скорость подачи', limitDepth: 'Предельная глубина', visualizations: 'Визуализации', chartRoughness: 'Шероховатость vs. Глубина', chartTaper: 'Конусность vs. Глубина', chartForces: 'Анализ сил', chartStress: 'Напряжение-Деформация', analysis: 'Анализ и Экспорт', costBreakdown: 'Разбивка затрат', comparison: 'Сравнение материалов', compareWith: 'Сравнить с', modelDetails: 'Детали модели', vrSimulation: 'VR/AR Симуляция', aiAssistant: 'AI Ассистент', export: 'Экспорт', saveProject: 'Сохранить проект', expertAnalysis: 'Экспертный анализ', generateAnalysis: 'Сгенерировать анализ', cutSimulation: 'Симуляция резки', paramAnalysis: 'Анализ параметров', dataViz: 'Визуализация данных', discreteResults: 'Дискретные результаты', depth: 'Глубина', garnet: 'Гранат', olivine: 'Оливин' },
  uk: { appTitle: 'Професійний калькулятор AWJ', level: 'Рівень', language: 'Мова', background: 'Фон', student: 'Студент', engineer: 'Інженер', manager: 'Менеджер', cutTime: 'Час різання', costPerPart: 'Вартість/Деталь', avgRoughness: 'Сер. Шорсткість', maxTaper: 'Макс. Конусність', productivity: 'Продуктивність', inputsConfig: 'Входи та Конфігурація', materialGeometry: 'Матеріал та Геометрія', material: 'Матеріал', thickness: 'Товщина (мм)', cutLength: 'Довжина різу (мм)', machineTooling: 'Верстат та Інструменти', pressure: 'Тиск насоса (МПа)', orificeId: 'Діаметр отвору (мм)', nozzleId: 'Діаметр сопла (мм)', abrasiveType: 'Тип абразиву', abrasiveFlow: 'Витрата абразиву (г/хв)', electricityCost: 'Вартість електроенергії (€/кВтг)', optimizationGoal: 'Мета оптимізації', tradeoff: 'Компроміс: Швидкість vs. Якість', eco: 'Еко', quality: 'Якість', predictionModel: 'Прогнозна модель', modelPhysical: 'Фізична модель', modelRegression: 'Регресійна модель', modelAnn: 'Нейронна мережа', modelGP: 'Гауссівський процес', modelSymbolic: 'Символічна регресія', modelHybrid: 'Гібридна модель', recommendedParams: 'Рекомендовані параметри', traverseSpeed: 'Швидкість подачі', limitDepth: 'Гранична глибина', visualizations: 'Візуалізації', chartRoughness: 'Шорсткість vs. Глибина', chartTaper: 'Конусність vs. Глибина', chartForces: 'Аналіз сил', chartStress: 'Напруга-Деформація', analysis: 'Аналіз та Експорт', costBreakdown: 'Розбивка витрат', comparison: 'Порівняння матеріалів', compareWith: 'Порівняти з', modelDetails: 'Деталі моделі', vrSimulation: 'VR/AR Симуляція', aiAssistant: 'AI Асистент', export: 'Експорт', saveProject: 'Зберегти проект', expertAnalysis: 'Експертний аналіз', generateAnalysis: 'Згенерувати аналіз', cutSimulation: 'Симуляція різання', paramAnalysis: 'Аналіз параметрів', dataViz: 'Візуалізація даних', discreteResults: 'Дискретні результати', depth: 'Глибина', garnet: 'Гранат', olivine: 'Олівін' },
  zh: { appTitle: 'AWJ专业计算器', level: '级别', language: '语言', background: '背景', student: '学生', engineer: '工程师', manager: '经理', cutTime: '切割时间', costPerPart: '成本/零件', avgRoughness: '平均粗糙度', maxTaper: '最大锥度', productivity: '生产力', inputsConfig: '输入和配置', materialGeometry: '材料和几何', material: '材料', thickness: '厚度 (mm)', cutLength: '切割长度 (mm)', machineTooling: '机器和工具', pressure: '泵压 (MPa)', orificeId: '孔径 (mm)', nozzleId: '喷嘴直径 (mm)', abrasiveType: '磨料类型', abrasiveFlow: '磨料流量 (g/min)', electricityCost: '电费 (€/kWh)', optimizationGoal: '优化目标', tradeoff: '权衡：速度 vs. 质量', eco: '经济', quality: '质量', predictionModel: '预测模型', modelPhysical: '物理模型', modelRegression: '回归模型', modelAnn: '神经网络', modelGP: '高斯过程', modelSymbolic: '符号回归', modelHybrid: '混合模型', recommendedParams: '推荐参数', traverseSpeed: '进给速度', limitDepth: '极限深度', visualizations: '可视化', chartRoughness: '粗糙度 vs. 深度', chartTaper: '锥度 vs. 深度', chartForces: '力分析', chartStress: '应力-应变', analysis: '分析和导出', costBreakdown: '成本明细', comparison: '材料比较', compareWith: '比较', modelDetails: '模型详情', vrSimulation: 'VR/AR 模拟', aiAssistant: 'AI 助手', export: '导出', saveProject: '保存项目', expertAnalysis: '专家分析', generateAnalysis: '生成分析', cutSimulation: '切割模拟', paramAnalysis: '参数分析', dataViz: '数据可视化', discreteResults: '离散结果', depth: '深度', garnet: '石榴石', olivine: '橄榄石' },
  ja: { appTitle: 'AWJプロフェッショナル計算機', level: 'レベル', language: '言語', background: '背景', student: '学生', engineer: 'エンジニア', manager: 'マネージャー', cutTime: '切断時間', costPerPart: 'コスト/部品', avgRoughness: '平均粗さ', maxTaper: '最大テーパー', productivity: '生産性', inputsConfig: '入力と設定', materialGeometry: '材料と形状', material: '材料', thickness: '厚さ (mm)', cutLength: '切断長さ (mm)', machineTooling: '機械とツール', pressure: 'ポンプ圧力 (MPa)', orificeId: 'オリフィス径 (mm)', nozzleId: 'ノズル径 (mm)', abrasiveType: '研磨材タイプ', abrasiveFlow: '研磨材流量 (g/min)', electricityCost: '電気代 (€/kWh)', optimizationGoal: '最適化目標', tradeoff: 'トレードオフ：速度 vs. 品質', eco: 'エコ', quality: '品質', predictionModel: '予測モデル', modelPhysical: '物理モデル', modelRegression: '回帰モデル', modelAnn: 'ニューラルネットワーク', modelGP: 'ガウス過程', modelSymbolic: '記号的回帰', modelHybrid: 'ハイブリッドモデル', recommendedParams: '推奨パラメータ', traverseSpeed: '送り速度', limitDepth: '限界深さ', visualizations: '可視化', chartRoughness: '粗さ vs. 深さ', chartTaper: 'テーパー vs. 深さ', chartForces: '力解析', chartStress: '応力-ひずみ', analysis: '分析とエクスポート', costBreakdown: 'コスト内訳', comparison: '材料比較', compareWith: '比較する', modelDetails: 'モデル詳細', vrSimulation: 'VR/ARシミュレーション', aiAssistant: 'AIアシスタント', export: 'エクスポート', saveProject: 'プロジェクト保存', expertAnalysis: '専門家分析', generateAnalysis: '分析生成', cutSimulation: '切断シミュレーション', paramAnalysis: 'パラメータ分析', dataViz: 'データ可視化', discreteResults: '離散結果', depth: '深さ', garnet: 'ガーネット', olivine: 'オリビン' },
  ko: { appTitle: 'AWJ 전문 계산기', level: '레벨', language: '언어', background: '배경', student: '학생', engineer: '엔지니어', manager: '관리자', cutTime: '절단 시간', costPerPart: '비용/부품', avgRoughness: '평균 거칠기', maxTaper: '최대 테이퍼', productivity: '생산성', inputsConfig: '입력 및 구성', materialGeometry: '재료 및 형상', material: '재료', thickness: '두께 (mm)', cutLength: '절단 길이 (mm)', machineTooling: '기계 및 도구', pressure: '펌프 압력 (MPa)', orificeId: '오리피스 직경 (mm)', nozzleId: '노즐 직경 (mm)', abrasiveType: '연마재 유형', abrasiveFlow: '연마재 유량 (g/min)', electricityCost: '전기 비용 (€/kWh)', optimizationGoal: '최적화 목표', tradeoff: '절충: 속도 vs. 품질', eco: '에코', quality: '품질', predictionModel: '예측 모델', modelPhysical: '물리적 모델', modelRegression: '회귀 모델', modelAnn: '신경망', modelGP: '가우스 프로세스', modelSymbolic: '기호 회귀', modelHybrid: '하이브리드 모델', recommendedParams: '권장 매개변수', traverseSpeed: '이송 속도', limitDepth: '한계 깊이', visualizations: '시각화', chartRoughness: '거칠기 vs. 깊이', chartTaper: '테이퍼 vs. 깊이', chartForces: '힘 분석', chartStress: '응력-변형률', analysis: '분석 및 내보내기', costBreakdown: '비용 분석', comparison: '재료 비교', compareWith: '비교', modelDetails: '모델 세부사항', vrSimulation: 'VR/AR 시뮬레이션', aiAssistant: 'AI 어시스턴트', export: '내보내기', saveProject: '프로젝트 저장', expertAnalysis: '전문가 분석', generateAnalysis: '분석 생성', cutSimulation: '절단 시뮬레이션', paramAnalysis: '매개변수 분석', dataViz: '데이터 시각화', discreteResults: '이산 결과', depth: '깊이', garnet: '가넷', olivine: '올리빈' },
  ar: { appTitle: 'حاسبة AWJ المحترفة', level: 'المستوى', language: 'اللغة', background: 'الخلفية', student: 'طالب', engineer: 'مهندس', manager: 'مدير', cutTime: 'وقت القطع', costPerPart: 'التكلفة/قطعة', avgRoughness: 'متوسط الخشونة', maxTaper: 'أقصى انحدار', productivity: 'الإنتاجية', inputsConfig: 'المدخلات والإعدادات', materialGeometry: 'المادة والهندسة', material: 'المادة', thickness: 'السمك (mm)', cutLength: 'طول القطع (mm)', machineTooling: 'الآلة والأدوات', pressure: 'ضغط المضخة (MPa)', orificeId: 'قطر الفتحة (mm)', nozzleId: 'قطر الفوهة (mm)', abrasiveType: 'نوع المادة الكاشطة', abrasiveFlow: 'تدفق المادة الكاشطة (g/min)', electricityCost: 'تكلفة الكهرباء (€/kWh)', optimizationGoal: 'هدف التحسين', tradeoff: 'المفاضلة: السرعة vs. الجودة', eco: 'اقتصادي', quality: 'جودة', predictionModel: 'نموذج التنبؤ', modelPhysical: 'نموذج فيزيائي', modelRegression: 'نموذج انحدار', modelAnn: 'شبكة عصبية', modelGP: 'عملية غاوسية', modelSymbolic: 'انحدار رمزي', modelHybrid: 'نموذج هجين', recommendedParams: 'المعاملات الموصى بها', traverseSpeed: 'سرعة التحرك', limitDepth: 'العمق الحدي', visualizations: 'التصورات', chartRoughness: 'الخشونة vs. العمق', chartTaper: 'الانحدار vs. العمق', chartForces: 'تحليل القوى', chartStress: 'الإجهاد-الانفعال', analysis: 'التحليل والتصدير', costBreakdown: 'تفصيل التكاليف', comparison: 'مقارنة المواد', compareWith: 'مقارنة مع', modelDetails: 'تفاصيل النموذج', vrSimulation: 'محاكاة VR/AR', aiAssistant: 'مساعد AI', export: 'تصدير', saveProject: 'حفظ المشروع', expertAnalysis: 'تحليل خبير', generateAnalysis: 'إنشاء التحليل', cutSimulation: 'محاكاة القطع', paramAnalysis: 'تحليل المعاملات', dataViz: 'تصور البيانات', discreteResults: 'النتائج المنفصلة', depth: 'العمق', garnet: 'جارنت', olivine: 'أوليفين' },
  tr: { appTitle: 'AWJ Profesyonel Hesaplayıcı', level: 'Seviye', language: 'Dil', background: 'Arka Plan', student: 'Öğrenci', engineer: 'Mühendis', manager: 'Yönetici', cutTime: 'Kesim Süresi', costPerPart: 'Maliyet/Parça', avgRoughness: 'Ort. Pürüzlülük', maxTaper: 'Maks. Koniklik', productivity: 'Verimlilik', inputsConfig: 'Girdiler ve Yapılandırma', materialGeometry: 'Malzeme ve Geometri', material: 'Malzeme', thickness: 'Kalınlık (mm)', cutLength: 'Kesim Uzunluğu (mm)', machineTooling: 'Makine ve Takımlar', pressure: 'Pompa Basıncı (MPa)', orificeId: 'Ağız Çapı (mm)', nozzleId: 'Nozul Çapı (mm)', abrasiveType: 'Aşındırıcı Tipi', abrasiveFlow: 'Aşındırıcı Akışı (g/dak)', electricityCost: 'Elektrik Maliyeti (€/kWh)', optimizationGoal: 'Optimizasyon Hedefi', tradeoff: 'Denge: Hız vs. Kalite', eco: 'Eko', quality: 'Kalite', predictionModel: 'Tahmin Modeli', modelPhysical: 'Fiziksel Model', modelRegression: 'Regresyon Modeli', modelAnn: 'Sinir Ağı', modelGP: 'Gauss Süreci', modelSymbolic: 'Sembolik Regresyon', modelHybrid: 'Hibrit Model', recommendedParams: 'Önerilen Parametreler', traverseSpeed: 'İlerleme Hızı', limitDepth: 'Sınır Derinliği', visualizations: 'Görselleştirmeler', chartRoughness: 'Pürüzlülük vs. Derinlik', chartTaper: 'Koniklik vs. Derinlik', chartForces: 'Kuvvet Analizi', chartStress: 'Gerilme-Gerinim', analysis: 'Analiz ve Dışa Aktarma', costBreakdown: 'Maliyet Dökümü', comparison: 'Malzeme Karşılaştırması', compareWith: 'Karşılaştır', modelDetails: 'Model Detayları', vrSimulation: 'VR/AR Simülasyonu', aiAssistant: 'AI Asistanı', export: 'Dışa Aktar', saveProject: 'Projeyi Kaydet', expertAnalysis: 'Uzman Analizi', generateAnalysis: 'Analiz Oluştur', cutSimulation: 'Kesim Simülasyonu', paramAnalysis: 'Parametre Analizi', dataViz: 'Veri Görselleştirme', discreteResults: 'Ayrık Sonuçlar', depth: 'Derinlik', garnet: 'Garnet', olivine: 'Olivin' },
  nl: { appTitle: 'AWJ Professionele Calculator', level: 'Niveau', language: 'Taal', background: 'Achtergrond', student: 'Student', engineer: 'Ingenieur', manager: 'Manager', cutTime: 'Snijtijd', costPerPart: 'Kosten/Deel', avgRoughness: 'Gem. Ruwheid', maxTaper: 'Max. Tapse', productivity: 'Productiviteit', inputsConfig: 'Invoer en Configuratie', materialGeometry: 'Materiaal en Geometrie', material: 'Materiaal', thickness: 'Dikte (mm)', cutLength: 'Snijlengte (mm)', machineTooling: 'Machine en Gereedschap', pressure: 'Pompdruk (MPa)', orificeId: 'Opening diameter (mm)', nozzleId: 'Mondstuk diameter (mm)', abrasiveType: 'Schuurmiddeltype', abrasiveFlow: 'Schuurmiddelstroom (g/min)', electricityCost: 'Elektriciteitskosten (€/kWh)', optimizationGoal: 'Optimalisatiedoel', tradeoff: 'Afweging: Snelheid vs. Kwaliteit', eco: 'Eco', quality: 'Kwaliteit', predictionModel: 'Voorspellingsmodel', modelPhysical: 'Fysisch model', modelRegression: 'Regressiemodel', modelAnn: 'Neuraal netwerk', modelGP: 'Gaussisch proces', modelSymbolic: 'Symbolische regressie', modelHybrid: 'Hybride model', recommendedParams: 'Aanbevolen parameters', traverseSpeed: 'Doorvoersnelheid', limitDepth: 'Limietdiepte', visualizations: 'Visualisaties', chartRoughness: 'Ruwheid vs. Diepte', chartTaper: 'Tapse vs. Diepte', chartForces: 'Krachtanalyse', chartStress: 'Spanning-Rek', analysis: 'Analyse en Export', costBreakdown: 'Kostenverdeling', comparison: 'Materiaalvergelijking', compareWith: 'Vergelijk met', modelDetails: 'Modeldetails', vrSimulation: 'VR/AR Simulatie', aiAssistant: 'AI Assistent', export: 'Exporteren', saveProject: 'Project opslaan', expertAnalysis: 'Expertanalyse', generateAnalysis: 'Analyse genereren', cutSimulation: 'Snijsimulatie', paramAnalysis: 'Parameteranalyse', dataViz: 'Datavisualisatie', discreteResults: 'Discrete resultaten', depth: 'Diepte', garnet: 'Granaat', olivine: 'Olivijn' },
  sv: { appTitle: 'AWJ Professionell Kalkylator', level: 'Nivå', language: 'Språk', background: 'Bakgrund', student: 'Student', engineer: 'Ingenjör', manager: 'Chef', cutTime: 'Skärtid', costPerPart: 'Kostnad/Del', avgRoughness: 'Gen. Råhet', maxTaper: 'Max. Koniskhet', productivity: 'Produktivitet', inputsConfig: 'Ingångar och Konfiguration', materialGeometry: 'Material och Geometri', material: 'Material', thickness: 'Tjocklek (mm)', cutLength: 'Skärlängd (mm)', machineTooling: 'Maskin och Verktyg', pressure: 'Pumptryck (MPa)', orificeId: 'Öppningsdiameter (mm)', nozzleId: 'Munstycksdiameter (mm)', abrasiveType: 'Slipmedelstyp', abrasiveFlow: 'Slipmedelsflöde (g/min)', electricityCost: 'Elkostnad (€/kWh)', optimizationGoal: 'Optimeringsmål', tradeoff: 'Avvägning: Hastighet vs. Kvalitet', eco: 'Eko', quality: 'Kvalitet', predictionModel: 'Prediktionsmodell', modelPhysical: 'Fysisk modell', modelRegression: 'Regressionsmodell', modelAnn: 'Neuralt nätverk', modelGP: 'Gaussisk process', modelSymbolic: 'Symbolisk regression', modelHybrid: 'Hybridmodell', recommendedParams: 'Rekommenderade parametrar', traverseSpeed: 'Matningshastighet', limitDepth: 'Gränsdjup', visualizations: 'Visualiseringar', chartRoughness: 'Råhet vs. Djup', chartTaper: 'Koniskhet vs. Djup', chartForces: 'Kraftanalys', chartStress: 'Spänning-Töjning', analysis: 'Analys och Export', costBreakdown: 'Kostnadsfördelning', comparison: 'Materialj ämförelse', compareWith: 'Jämför med', modelDetails: 'Modelldetaljer', vrSimulation: 'VR/AR Simulering', aiAssistant: 'AI Assistent', export: 'Exportera', saveProject: 'Spara projekt', expertAnalysis: 'Expertanalys', generateAnalysis: 'Generera analys', cutSimulation: 'Skärsimulering', paramAnalysis: 'Parameteranalys', dataViz: 'Datavisualisering', discreteResults: 'Diskreta resultat', depth: 'Djup', garnet: 'Granat', olivine: 'Olivin' },
  no: { appTitle: 'AWJ Profesjonell Kalkulator', level: 'Nivå', language: 'Språk', background: 'Bakgrunn', student: 'Student', engineer: 'Ingeniør', manager: 'Leder', cutTime: 'Skjæretid', costPerPart: 'Kostnad/Del', avgRoughness: 'Gj.snitt Ruhet', maxTaper: 'Maks. Koniskhet', productivity: 'Produktivitet', inputsConfig: 'Inndata og Konfigurasjon', materialGeometry: 'Materiale og Geometri', material: 'Materiale', thickness: 'Tykkelse (mm)', cutLength: 'Skjærelengde (mm)', machineTooling: 'Maskin og Verktøy', pressure: 'Pumpetrykk (MPa)', orificeId: 'Åpningsdiameter (mm)', nozzleId: 'Munnstykke diameter (mm)', abrasiveType: 'Slipemiddeltype', abrasiveFlow: 'Slipemiddelstrøm (g/min)', electricityCost: 'Strømkostnad (€/kWh)', optimizationGoal: 'Optimeringsmål', tradeoff: 'Avveining: Hastighet vs. Kvalitet', eco: 'Øko', quality: 'Kvalitet', predictionModel: 'Prediksjonsmodell', modelPhysical: 'Fysisk modell', modelRegression: 'Regresjonsmodell', modelAnn: 'Nevrale nettverk', modelGP: 'Gaussisk prosess', modelSymbolic: 'Symbolsk regresjon', modelHybrid: 'Hybridmodell', recommendedParams: 'Anbefalte parametere', traverseSpeed: 'Matehastighet', limitDepth: 'Grensedybde', visualizations: 'Visualiseringer', chartRoughness: 'Ruhet vs. Dybde', chartTaper: 'Koniskhet vs. Dybde', chartForces: 'Kraftanalyse', chartStress: 'Spenning-Tøyning', analysis: 'Analyse og Eksport', costBreakdown: 'Kostnadsfordeling', comparison: 'Materialsammenligning', compareWith: 'Sammenlign med', modelDetails: 'Modelldetaljer', vrSimulation: 'VR/AR Simulering', aiAssistant: 'AI Assistent', export: 'Eksporter', saveProject: 'Lagre prosjekt', expertAnalysis: 'Ekspertanalyse', generateAnalysis: 'Generer analyse', cutSimulation: 'Skjæresimulering', paramAnalysis: 'Parameteranalyse', dataViz: 'Datavisualisering', discreteResults: 'Diskrete resultater', depth: 'Dybde', garnet: 'Granat', olivine: 'Olivin' },
  da: { appTitle: 'AWJ Professionel Beregner', level: 'Niveau', language: 'Sprog', background: 'Baggrund', student: 'Student', engineer: 'Ingeniør', manager: 'Leder', cutTime: 'Skæretid', costPerPart: 'Omkostning/Del', avgRoughness: 'Gennem. Ruhed', maxTaper: 'Maks. Koniskhed', productivity: 'Produktivitet', inputsConfig: 'Input og Konfiguration', materialGeometry: 'Materiale og Geometri', material: 'Materiale', thickness: 'Tykkelse (mm)', cutLength: 'Skærelængde (mm)', machineTooling: 'Maskine og Værktøj', pressure: 'Pumpetryk (MPa)', orificeId: 'Åbningsdiameter (mm)', nozzleId: 'Dysediameter (mm)', abrasiveType: 'Slibemiddeltype', abrasiveFlow: 'Slibemiddelstrøm (g/min)', electricityCost: 'Elomkostning (€/kWh)', optimizationGoal: 'Optimeringsmål', tradeoff: 'Afvejning: Hastighed vs. Kvalitet', eco: 'Øko', quality: 'Kvalitet', predictionModel: 'Forudsigelsesmodel', modelPhysical: 'Fysisk model', modelRegression: 'Regressionsmodel', modelAnn: 'Neuralt netværk', modelGP: 'Gaussisk proces', modelSymbolic: 'Symbolsk regression', modelHybrid: 'Hybridmodel', recommendedParams: 'Anbefalede parametre', traverseSpeed: 'Fremføringshastighed', limitDepth: 'Grænsedybde', visualizations: 'Visualiseringer', chartRoughness: 'Ruhed vs. Dybde', chartTaper: 'Koniskhed vs. Dybde', chartForces: 'Kraftanalyse', chartStress: 'Spænding-Tøjning', analysis: 'Analyse og Eksport', costBreakdown: 'Omkostningsfordeling', comparison: 'Materialesammenligning', compareWith: 'Sammenlign med', modelDetails: 'Modeldetaljer', vrSimulation: 'VR/AR Simulering', aiAssistant: 'AI Assistent', export: 'Eksporter', saveProject: 'Gem projekt', expertAnalysis: 'Ekspertanalyse', generateAnalysis: 'Generer analyse', cutSimulation: 'Skæresimulering', paramAnalysis: 'Parameteranalyse', dataViz: 'Datavisualisering', discreteResults: 'Diskrete resultater', depth: 'Dybde', garnet: 'Granat', olivine: 'Olivin' },
  fi: { appTitle: 'AWJ Ammattimainen Laskin', level: 'Taso', language: 'Kieli', background: 'Tausta', student: 'Opiskelija', engineer: 'Insinööri', manager: 'Johtaja', cutTime: 'Leikkausaika', costPerPart: 'Hinta/Osa', avgRoughness: 'Keskim. Karheus', maxTaper: 'Maks. Kartio', productivity: 'Tuottavuus', inputsConfig: 'Syötteet ja Konfiguraatio', materialGeometry: 'Materiaali ja Geometria', material: 'Materiaali', thickness: 'Paksuus (mm)', cutLength: 'Leikkauspituus (mm)', machineTooling: 'Kone ja Työkalut', pressure: 'Pumppupaine (MPa)', orificeId: 'Aukon halkaisija (mm)', nozzleId: 'Suuttimen halkaisija (mm)', abrasiveType: 'Hioma-ainetyyppi', abrasiveFlow: 'Hioma-ainevirtaus (g/min)', electricityCost: 'Sähkökustannus (€/kWh)', optimizationGoal: 'Optimointitavoite', tradeoff: 'Kompromissi: Nopeus vs. Laatu', eco: 'Eko', quality: 'Laatu', predictionModel: 'Ennustemalli', modelPhysical: 'Fysikaalinen malli', modelRegression: 'Regressiomalli', modelAnn: 'Neuroverkko', modelGP: 'Gaussinen prosessi', modelSymbolic: 'Symbolinen regressio', modelHybrid: 'Hybridimalli', recommendedParams: 'Suositellut parametrit', traverseSpeed: 'Syöttönopeus', limitDepth: 'Rajasyvyys', visualizations: 'Visualisoinnit', chartRoughness: 'Karheus vs. Syvyys', chartTaper: 'Kartio vs. Syvyys', chartForces: 'Voimaanalyysi', chartStress: 'Jännitys-Venymä', analysis: 'Analyysi ja Vienti', costBreakdown: 'Kustannuserittely', comparison: 'Materiaalien vertailu', compareWith: 'Vertaa', modelDetails: 'Mallin yksityiskohdat', vrSimulation: 'VR/AR Simulaatio', aiAssistant: 'AI Avustaja', export: 'Vie', saveProject: 'Tallenna projekti', expertAnalysis: 'Asiantuntija-analyysi', generateAnalysis: 'Luo analyysi', cutSimulation: 'Leikkaussimulaatio', paramAnalysis: 'Parametrianalyysi', dataViz: 'Datan visualisointi', discreteResults: 'Diskreetit tulokset', depth: 'Syvyys', garnet: 'Granaatti', olivine: 'Oliviini' },
  pt: { appTitle: 'Calculadora AWJ Profissional', level: 'Nível', language: 'Idioma', background: 'Fundo', student: 'Estudante', engineer: 'Engenheiro', manager: 'Gerente', cutTime: 'Tempo de corte', costPerPart: 'Custo/Peça', avgRoughness: 'Rugosidade Média', maxTaper: 'Conicidade Máx.', productivity: 'Produtividade', inputsConfig: 'Entradas e Configuração', materialGeometry: 'Material e Geometria', material: 'Material', thickness: 'Espessura (mm)', cutLength: 'Comprimento de corte (mm)', machineTooling: 'Máquina e Ferramentas', pressure: 'Pressão da bomba (MPa)', orificeId: 'Diâmetro do orifício (mm)', nozzleId: 'Diâmetro do bocal (mm)', abrasiveType: 'Tipo de abrasivo', abrasiveFlow: 'Fluxo de abrasivo (g/min)', electricityCost: 'Custo de eletricidade (€/kWh)', optimizationGoal: 'Objetivo de otimização', tradeoff: 'Equilíbrio: Velocidade vs. Qualidade', eco: 'Eco', quality: 'Qualidade', predictionModel: 'Modelo de previsão', modelPhysical: 'Modelo físico', modelRegression: 'Modelo de regressão', modelAnn: 'Rede neural', modelGP: 'Processo gaussiano', modelSymbolic: 'Regressão simbólica', modelHybrid: 'Modelo híbrido', recommendedParams: 'Parâmetros recomendados', traverseSpeed: 'Velocidade de avanço', limitDepth: 'Profundidade limite', visualizations: 'Visualizações', chartRoughness: 'Rugosidade vs. Profundidade', chartTaper: 'Conicidade vs. Profundidade', chartForces: 'Análise de forças', chartStress: 'Tensão-Deformação', analysis: 'Análise e Exportação', costBreakdown: 'Distribuição de custos', comparison: 'Comparação de materiais', compareWith: 'Comparar com', modelDetails: 'Detalhes do modelo', vrSimulation: 'Simulação VR/AR', aiAssistant: 'Assistente IA', export: 'Exportar', saveProject: 'Salvar projeto', expertAnalysis: 'Análise especializada', generateAnalysis: 'Gerar análise', cutSimulation: 'Simulação de corte', paramAnalysis: 'Análise de parâmetros', dataViz: 'Visualização de dados', discreteResults: 'Resultados discretos', depth: 'Profundidade', garnet: 'Granada', olivine: 'Olivina' },
  ro: { appTitle: 'Calculator AWJ Profesional', level: 'Nivel', language: 'Limbă', background: 'Fundal', student: 'Student', engineer: 'Inginer', manager: 'Manager', cutTime: 'Timp de tăiere', costPerPart: 'Cost/Piesă', avgRoughness: 'Rugozitate Medie', maxTaper: 'Conicitate Max', productivity: 'Productivitate', inputsConfig: 'Intrări și Configurare', materialGeometry: 'Material și Geometrie', material: 'Material', thickness: 'Grosime (mm)', cutLength: 'Lungime tăiere (mm)', machineTooling: 'Mașină și Scule', pressure: 'Presiune pompă (MPa)', orificeId: 'Diametru orificiu (mm)', nozzleId: 'Diametru duză (mm)', abrasiveType: 'Tip abraziv', abrasiveFlow: 'Flux abraziv (g/min)', electricityCost: 'Cost electricitate (€/kWh)', optimizationGoal: 'Obiectiv optimizare', tradeoff: 'Compromis: Viteză vs. Calitate', eco: 'Eco', quality: 'Calitate', predictionModel: 'Model de predicție', modelPhysical: 'Model fizic', modelRegression: 'Model de regresie', modelAnn: 'Rețea neuronală', modelGP: 'Proces gaussian', modelSymbolic: 'Regresie simbolică', modelHybrid: 'Model hibrid', recommendedParams: 'Parametri recomandați', traverseSpeed: 'Viteză avansare', limitDepth: 'Adâncime limită', visualizations: 'Vizualizări', chartRoughness: 'Rugozitate vs. Adâncime', chartTaper: 'Conicitate vs. Adâncime', chartForces: 'Analiză forțe', chartStress: 'Tensiune-Deformare', analysis: 'Analiză și Export', costBreakdown: 'Defalcare costuri', comparison: 'Comparație materiale', compareWith: 'Compară cu', modelDetails: 'Detalii model', vrSimulation: 'Simulare VR/AR', aiAssistant: 'Asistent IA', export: 'Export', saveProject: 'Salvează proiect', expertAnalysis: 'Analiză expert', generateAnalysis: 'Generează analiză', cutSimulation: 'Simulare tăiere', paramAnalysis: 'Analiză parametri', dataViz: 'Vizualizare date', discreteResults: 'Rezultate discrete', depth: 'Adâncime', garnet: 'Granat', olivine: 'Olivină' }
};

const AWJCalculator = () => {
  const [language, setLanguage] = useState('en');
  const [userLevel, setUserLevel] = useState('engineer');
  const [bgColor, setBgColor] = useState('#111827');
  
  const [material, setMaterial] = useState(MATERIALS_DATABASE[0]);
  const [thickness, setThickness] = useState(8);
  const [cutLength, setCutLength] = useState(1000);
  const [pressure, setPressure] = useState(300);
  const [abrasiveFlow, setAbrasiveFlow] = useState(450);
  const [orificeId, setOrificeId] = useState(0.30);
  const [nozzleId, setNozzleId] = useState(1.02);
  const [abrasiveType, setAbrasiveType] = useState('garnet');
  const [optimizationLevel, setOptimizationLevel] = useState(3);
  const [electricityCost, setElectricityCost] = useState(0.15);
  const [model, setModel] = useState('hybrid');
  
  const [results, setResults] = useState(null);
  const [chartType, setChartType] = useState('roughness');
  const [showVR, setShowVR] = useState(false);
  const [vrScene, setVRScene] = useState('simulation');
  const [showChat, setShowChat] = useState(false);
  const [chatMessages, setChatMessages] = useState([]);
  const [chatInput, setChatInput] = useState('');
  const [projects, setProjects] = useState([]);
  const [comparisonMaterial, setComparisonMaterial] = useState(null);
  const [expertAnalysis, setExpertAnalysis] = useState('');

  useEffect(() => {
    setChatMessages([{ text: t('aiAssistant') + ": 👋 Ask me about Yret, Ra, Kawj, parameters, or optimization!", bot: true }]);
  }, [language]);

  const calculateResults = () => {
    const Emat = material.youngModulus * 1000;
    const Kawj = 1e12 / Math.pow(Emat, 2);
    
    const qualityFactor = 1.5 - ((optimizationLevel - 1) * 0.25);
    const pressureFactor = Math.pow(pressure / 300, 0.3);
    const abrasiveFactor = Math.pow(abrasiveFlow / 450, 0.2);
    const nozzleFactor = nozzleId / 1.02;
    const abrasiveTypeFactor = abrasiveType === 'garnet' ? 1.0 : 0.95;
    
    const Vpopt_base = (Math.pow(1e-3 * 3.7, 0.5) * 1e6) / Math.pow(Emat, 0.5);
    const Vpopt = (Vpopt_base / qualityFactor) * pressureFactor * abrasiveFactor * nozzleFactor * abrasiveTypeFactor;
    
    const cutTimeMin = cutLength / Vpopt;
    const cutTimeHours = cutTimeMin / 60;
    
    const powerConsumption = (pressure * 0.01) * 1.5;
    const energyCost = powerConsumption * cutTimeHours * electricityCost;
    const abrasiveCost = (abrasiveFlow * cutTimeMin / 1000) * (abrasiveType === 'garnet' ? 0.5 : 0.45);
    const laborCost = cutTimeHours * 30;
    const toolWearCost = cutTimeHours * 5;
    
    const totalCost = energyCost + abrasiveCost + laborCost + toolWearCost;
    
    const depthPoints = 20;
    const profile = Array.from({ length: depthPoints }, (_, i) => {
      const h = thickness * (i + 1) / depthPoints;
      const depthRatio = h / thickness;
      
      const Ra_initial = 1.5;
      const Ra_increase = Math.pow(depthRatio, 1.5) * 8;
      const Ra = Ra_initial + Ra_increase;
      
      const Yret = Ra * h / (Kawj + 1);
      const taper = Math.atan(Yret / h) * (180 / Math.PI);
      
      const Fh = 4.0 + depthRatio * 2.5;
      const Fv = 8.0 + depthRatio * 3.0;
      const FRa = 0.5 + Ra * 0.4;
      
      const kerfWidth = nozzleId + Yret * 2;
      
      return {
        h: h.toFixed(2),
        Ra: Ra.toFixed(2),
        Yret: Yret.toFixed(3),
        taper: taper.toFixed(3),
        forces: { Fh: Fh.toFixed(2), Fv: Fv.toFixed(2), FRa: FRa.toFixed(2) },
        kerfWidth: kerfWidth.toFixed(3)
      };
    });
    
    const strainPoints = 50;
    const stressStrain = Array.from({ length: strainPoints }, (_, i) => {
      const strain = i * 0.001;
      const stress = Math.min(Emat * strain, material.tensileStrength);
      return { strain: (strain * 100).toFixed(2), stress: stress.toFixed(1) };
    });
    
    const avgRa = profile.reduce((sum, p) => sum + parseFloat(p.Ra), 0) / profile.length;
    const maxTaper = Math.max(...profile.map(p => parseFloat(p.taper)));
    const surfaceQuality = avgRa < 3 ? 'Excellent' : avgRa < 6 ? 'Good' : 'Acceptable';
    
    const productivity = (cutLength / 1000) / cutTimeHours;
    const costPerMeter = totalCost / (cutLength / 1000);
    
    const toolLifeHours = 100 - (pressure / 600 * 50) - (abrasiveFlow / 800 * 30);
    const maintenanceInterval = Math.floor(toolLifeHours / cutTimeHours);
    
    return {
      Vpopt: Vpopt.toFixed(2),
      pressure: pressure.toFixed(0),
      abrasiveFlow: abrasiveFlow.toFixed(0),
      Hlim: Kawj.toFixed(2),
      Kawj: Kawj.toFixed(2),
      cutTimeMin: cutTimeMin.toFixed(2),
      cutTimeHours: cutTimeHours.toFixed(3),
      totalCost: totalCost.toFixed(2),
      costs: {
        energy: energyCost.toFixed(2),
        abrasive: abrasiveCost.toFixed(2),
        labor: laborCost.toFixed(2),
        toolWear: toolWearCost.toFixed(2)
      },
      profile,
      stressStrain,
      avgRa: avgRa.toFixed(2),
      maxTaper: maxTaper.toFixed(3),
      surfaceQuality,
      productivity: productivity.toFixed(2),
      costPerMeter: costPerMeter.toFixed(2),
      powerConsumption: powerConsumption.toFixed(2),
      toolLifeHours: toolLifeHours.toFixed(1),
      maintenanceInterval
    };
  };

  useEffect(() => {
    const newResults = calculateResults();
    setResults(newResults);
  }, [material, thickness, cutLength, pressure, abrasiveFlow, orificeId, nozzleId, abrasiveType, optimizationLevel, electricityCost, model]);

  const generateExpertAnalysis = () => {
    if (!results) return;
    
    const analysis = `
**AWJ Process Analysis Report**
Generated: ${new Date().toLocaleString()}
Model: ${model.toUpperCase()}

**Material Analysis:**
- Material: ${material.name[language]}
- Young's Modulus: ${material.youngModulus} GPa
- Kawj Constant: ${results.Kawj} mm
- Tensile Strength: ${material.tensileStrength} MPa

**Cutting Parameters:**
- Optimal Speed: ${results.Vpopt} mm/min
- Pressure: ${pressure} MPa
- Abrasive Flow: ${abrasiveFlow} g/min (${abrasiveType})
- Nozzle: ${nozzleId} mm

**Quality Assessment:**
- Surface Quality: ${results.surfaceQuality}
- Average Roughness: ${results.avgRa} µm
- Maximum Taper: ${results.maxTaper}°
- Quality Score: ${10 - parseFloat(results.avgRa)}/ 10

**Performance Metrics:**
- Productivity: ${results.productivity} m/hour
- Cut Time: ${Math.floor(parseFloat(results.cutTimeMin))}:${String(Math.round((parseFloat(results.cutTimeMin) % 1) * 60)).padStart(2, '0')}
- Cost per Part: €${results.totalCost}
- Cost per Meter: €${results.costPerMeter}

**Cost Breakdown:**
- Energy: €${results.costs.energy} (${(parseFloat(results.costs.energy) / parseFloat(results.totalCost) * 100).toFixed(1)}%)
- Abrasive: €${results.costs.abrasive} (${(parseFloat(results.costs.abrasive) / parseFloat(results.totalCost) * 100).toFixed(1)}%)
- Labor: €${results.costs.labor} (${(parseFloat(results.costs.labor) / parseFloat(results.totalCost) * 100).toFixed(1)}%)
- Tool Wear: €${results.costs.toolWear} (${(parseFloat(results.costs.toolWear) / parseFloat(results.totalCost) * 100).toFixed(1)}%)

**Recommendations:**
${parseFloat(results.avgRa) > 5 ? '⚠️ Consider reducing cutting speed by 20% to improve surface finish' : '✓ Surface quality is optimal'}
${parseFloat(results.maxTaper) > 1 ? '⚠️ Increase pressure to reduce taper deviation' : '✓ Taper is within acceptable limits'}
${optimizationLevel < 3 ? '💡 Current settings prioritize cost over quality' : optimizationLevel > 3 ? '💡 Current settings prioritize quality over speed' : '💡 Balanced optimization selected'}

**Tool Maintenance:**
- Estimated Tool Life: ${results.toolLifeHours} hours
- Maintenance Interval: Every ${results.maintenanceInterval} parts
- Next Service: After ${results.maintenanceInterval} parts

**Process Efficiency:**
Power Consumption: ${results.powerConsumption} kW
Energy Efficiency: ${(parseFloat(results.productivity) * 10 / parseFloat(results.powerConsumption)).toFixed(2)} m/kW
`;
    
    setExpertAnalysis(analysis);
  };

  const handleSendMessage = () => {
    if (!chatInput.trim()) return;
    
    setChatMessages(prev => [...prev, { text: chatInput, bot: false }]);
    
    setTimeout(() => {
      const response = generateAIResponse(chatInput.toLowerCase());
      setChatMessages(prev => [...prev, { text: response, bot: true }]);
    }, 500);
    
    setChatInput('');
  };

  const generateAIResponse = (query) => {
    if (!results) return "Please run a calculation first!";
    
    if (query.includes('yret') || query.includes('taper')) {
      return `**Yret (Taper Deviation)**: Current: ${results.maxTaper}°. ${parseFloat(results.maxTaper) < 0.5 ? 'Excellent!' : parseFloat(results.maxTaper) < 1 ? 'Good' : 'Acceptable'}. To improve: increase pressure to ${Math.min(600, pressure + 50)} MPa.`;
    }
    
    if (query.includes('ra') || query.includes('roughness')) {
      return `**Surface Roughness (Ra)**: Avg: ${results.avgRa} µm - ${results.surfaceQuality}. At max depth: ${results.profile[results.profile.length-1].Ra} µm. To improve: reduce speed to ${(parseFloat(results.Vpopt) * 0.8).toFixed(0)} mm/min.`;
    }
    
    if (query.includes('kawj')) {
      return `**Kawj**: ${results.Kawj} mm for ${material.name[language]}. This determines max depth (${results.Hlim} mm). Formula: Kawj = 10¹² / E² where E = ${material.youngModulus} GPa.`;
    }
    
    if (query.includes('cost')) {
      return `**Cost**: €${results.totalCost}/part. Energy: €${results.costs.energy}, Abrasive: €${results.costs.abrasive}, Labor: €${results.costs.labor}, Tool: €${results.costs.toolWear}. Cost/m: €${results.costPerMeter}`;
    }
    
    if (query.includes('quality') || query.includes('improve')) {
      return `**Quality Tips**: ${parseFloat(results.avgRa) > 4 ? `Reduce speed to ${(parseFloat(results.Vpopt) * 0.7).toFixed(0)} mm/min. ` : ''}${parseFloat(results.maxTaper) > 0.8 ? `Increase pressure to ${Math.min(600, pressure + 100)} MPa. ` : ''}${abrasiveFlow < 500 ? 'Increase abrasive to 500-600 g/min.' : 'Parameters optimized!'}`;
    }
    
    if (query.includes('speed') || query.includes('time')) {
      return `**Speed**: ${results.Vpopt} mm/min. Cut time: ${Math.floor(parseFloat(results.cutTimeMin))}:${String(Math.round((parseFloat(results.cutTimeMin) % 1) * 60)).padStart(2, '0')}. Productivity: ${results.productivity} m/h.`;
    }
    
    if (query.includes('parameter')) {
      return `**Parameters**: Material: ${material.name[language]}, Thickness: ${thickness}mm, Pressure: ${pressure}MPa, Abrasive: ${abrasiveFlow}g/min, Speed: ${results.Vpopt}mm/min, Quality: ${results.surfaceQuality}`;
    }
    
    return "I can help with: Yret, Ra, Kawj, cost, quality, speed, or parameters. What would you like to know?";
  };

  const exportResults = (format) => {
    if (!results) return;
    
    if (format === 'csv') {
      let csv = 'Depth(mm),Ra(µm),Yret(mm),Taper(°),Fh(N),Fv(N),FRa(N)\n';
      results.profile.forEach(p => {
        csv += `${p.h},${p.Ra},${p.Yret},${p.taper},${p.forces.Fh},${p.forces.Fv},${p.forces.FRa}\n`;
      });
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'awj_results.csv';
      a.click();
    } else if (format === 'json') {
      const data = JSON.stringify({ 
        material: material.name[language], 
        parameters: { thickness, pressure, abrasiveFlow, nozzleId, orificeId, abrasiveType }, 
        results 
      }, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'awj_project.json';
      a.click();
    }
  };

  const t = (key) => TRANSLATIONS[language]?.[key] || key;

  const renderChart = () => {
    if (!results) return null;
    
    const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6'];
    
    switch(chartType) {
      case 'roughness':
        return (
          <ResponsiveContainer width="100%" height={300}>
            <AreaChart data={results.profile.map(p => ({ depth: p.h, Ra: parseFloat(p.Ra) }))}>
              <defs>
                <linearGradient id="colorRa" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="5%" stopColor={colors[0]} stopOpacity={0.8}/>
                  <stop offset="95%" stopColor={colors[0]} stopOpacity={0}/>
                </linearGradient>
              </defs>
              <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
              <XAxis dataKey="depth" stroke="#9CA3AF" label={{ value: t('depth') + ' (mm)', position: 'bottom', fill: '#9CA3AF' }} />
              <YAxis stroke="#9CA3AF" label={{ value: 'Ra (µm)', angle: -90, position: 'left', fill: '#9CA3AF' }} />
              <Tooltip contentStyle={{ backgroundColor: '#1F2937', border: '1px solid #374151' }} />
              <Area type="monotone" dataKey="Ra" stroke={colors[0]} fillOpacity={1} fill="url(#colorRa)" />
            </AreaChart>
          </ResponsiveContainer>
        );
      
      case 'taper':
        return (
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={results.profile.map(p => ({ depth: p.h, taper: parseFloat(p.taper), yret: parseFloat(p.Yret) * 1000 }))}>
              <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
              <XAxis dataKey="depth" stroke="#9CA3AF" />
              <YAxis stroke="#9CA3AF" />
              <Tooltip contentStyle={{ backgroundColor: '#1F2937', border: '1px solid #374151' }} />
              <Legend />
              <Line type="monotone" dataKey="taper" stroke={colors[1]} name="Taper (°)" strokeWidth={2} />
              <Line type="monotone" dataKey="yret" stroke={colors[2]} name="Yret (µm)" strokeWidth={2} />
            </LineChart>
          </ResponsiveContainer>
        );
      
      case 'forces':
        return (
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={results.profile.map(p => ({ 
              depth: p.h, 
              Fh: parseFloat(p.forces.Fh), 
              Fv: parseFloat(p.forces.Fv),
              FRa: parseFloat(p.forces.FRa)
            }))}>
              <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
              <XAxis dataKey="depth" stroke="#9CA3AF" />
              <YAxis stroke="#9CA3AF" />
              <Tooltip contentStyle={{ backgroundColor: '#1F2937', border: '1px solid #374151' }} />
              <Legend />
              <Line type="monotone" dataKey="Fh" stroke={colors[0]} name="Fh (N)" strokeWidth={2} />
              <Line type="monotone" dataKey="Fv" stroke={colors[1]} name="Fv (N)" strokeWidth={2} />
              <Line type="monotone" dataKey="FRa" stroke={colors[2]} name="FRa (N)" strokeWidth={2} />
            </LineChart>
          </ResponsiveContainer>
        );
      
      case 'stress':
        return (
          <ResponsiveContainer width="100%" height={300}>
            <AreaChart data={results.stressStrain.map(p => ({ strain: parseFloat(p.strain), stress: parseFloat(p.stress) }))}>
              <defs>
                <linearGradient id="colorStress" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="5%" stopColor={colors[3]} stopOpacity={0.8}/>
                  <stop offset="95%" stopColor={colors[3]} stopOpacity={0}/>
                </linearGradient>
              </defs>
              <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
              <XAxis dataKey="strain" stroke="#9CA3AF" label={{ value: 'Strain (%)', position: 'bottom', fill: '#9CA3AF' }} />
              <YAxis stroke="#9CA3AF" label={{ value: 'Stress (MPa)', angle: -90, position: 'left', fill: '#9CA3AF' }} />
              <Tooltip contentStyle={{ backgroundColor: '#1F2937', border: '1px solid #374151' }} />
              <Area type="monotone" dataKey="stress" stroke={colors[3]} fillOpacity={1} fill="url(#colorStress)" />
            </AreaChart>
          </ResponsiveContainer>
        );
      
      default:
        return null;
    }
  };

  const renderComparison = () => {
    if (!comparisonMaterial || !results) return null;
    
    const compMat = MATERIALS_DATABASE.find(m => m.id === comparisonMaterial);
    if (!compMat) return null;
    
    const tempResults = calculateResults();
    const origMat = material;
    const origResults = results;
    
    return (
      <div className="text-sm space-y-2">
        <div className="flex justify-between">
          <span className="text-gray-400">Material:</span>
          <span>{origMat.name[language]} vs {compMat.name[language]}</span>
        </div>
        <div className="flex justify-between">
          <span className="text-gray-400">Kawj:</span>
          <span>{origResults.Kawj} vs {(1e12 / Math.pow(compMat.youngModulus * 1000, 2)).toFixed(2)} mm</span>
        </div>
        <div className="flex justify-between">
          <span className="text-gray-400">Speed:</span>
          <span className={parseFloat(origResults.Vpopt) > 500 ? 'text-green-400' : 'text-yellow-400'}>{origResults.Vpopt} mm/min</span>
        </div>
        <div className="flex justify-between">
          <span className="text-gray-400">Cost:</span>
          <span className={parseFloat(origResults.totalCost) < 50 ? 'text-green-400' : 'text-yellow-400'}>€{origResults.totalCost}</span>
        </div>
      </div>
    );
  };

  return (
    <div className="flex flex-col h-screen" style={{ backgroundColor: bgColor, color: '#E5E7EB' }}>
      <header className="bg-gray-800 shadow-lg p-3 flex flex-wrap justify-between items-center border-b border-gray-700">
        <div className="flex items-center space-x-3">
          <h1 className="text-xl font-bold bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">
            {t('appTitle')}
          </h1>
          <span className="px-2 py-1 bg-blue-600 text-white text-xs rounded-full font-semibold">PRO</span>
        </div>
        
        <div className="flex items-center space-x-3">
          <select value={userLevel} onChange={(e) => setUserLevel(e.target.value)} className="bg-gray-700 text-white border border-gray-600 rounded-md px-2 py-1 text-sm">
            <option value="student">{t('student')}</option>
            <option value="engineer">{t('engineer')}</option>
            <option value="manager">{t('manager')}</option>
          </select>
          
          <select value={language} onChange={(e) => setLanguage(e.target.value)} className="bg-gray-700 text-white border border-gray-600 rounded-md px-2 py-1 text-sm">
            <option value="en">🇬🇧 English</option>
            <option value="cs">🇨🇿 Čeština</option>
            <option value="sk">🇸🇰 Slovenčina</option>
            <option value="de">🇩🇪 Deutsch</option>
            <option value="fr">🇫🇷 Français</option>
            <option value="es">🇪🇸 Español</option>
            <option value="it">🇮🇹 Italiano</option>
            <option value="pl">🇵🇱 Polski</option>
            <option value="ru">🇷🇺 Русский</option>
            <option value="uk">🇺🇦 Українська</option>
            <option value="zh">🇨🇳 中文</option>
            <option value="ja">🇯🇵 日本語</option>
            <option value="ko">🇰🇷 한국어</option>
            <option value="ar">🇸🇦 العربية</option>
            <option value="tr">🇹🇷 Türkçe</option>
            <option value="nl">🇳🇱 Nederlands</option>
            <option value="sv">🇸🇪 Svenska</option>
            <option value="no">🇳🇴 Norsk</option>
            <option value="da">🇩🇰 Dansk</option>
            <option value="fi">🇫🇮 Suomi</option>
            <option value="pt">🇵🇹 Português</option>
            <option value="ro">🇷🇴 Română</option>
          </select>
          
          <input type="color" value={bgColor} onChange={(e) => setBgColor(e.target.value)} className="w-8 h-8 rounded cursor-pointer" />
        </div>
      </header>

      {results && (
        <div className="bg-gray-800 border-y border-gray-700 p-3 grid grid-cols-5 gap-3">
          <div className="text-center">
            <div className="text-xs text-gray-400 uppercase mb-1">{t('cutTime')}</div>
            <div className="text-lg font-bold text-blue-400">{Math.floor(parseFloat(results.cutTimeMin))}:{String(Math.round((parseFloat(results.cutTimeMin) % 1) * 60)).padStart(2, '0')}</div>
          </div>
          <div className="text-center">
            <div className="text-xs text-gray-400 uppercase mb-1">{t('costPerPart')}</div>
            <div className="text-lg font-bold text-green-400">€{results.totalCost}</div>
          </div>
          <div className="text-center">
            <div className="text-xs text-gray-400 uppercase mb-1">{t('avgRoughness')}</div>
            <div className="text-lg font-bold text-orange-400">{results.avgRa} µm</div>
          </div>
          <div className="text-center">
            <div className="text-xs text-gray-400 uppercase mb-1">{t('maxTaper')}</div>
            <div className="text-lg font-bold text-red-400">{results.maxTaper}°</div>
          </div>
          <div className="text-center">
            <div className="text-xs text-gray-400 uppercase mb-1">{t('productivity')}</div>
            <div className="text-lg font-bold text-purple-400">{results.productivity} m/h</div>
          </div>
        </div>
      )}

      <div className="flex-1 flex overflow-hidden">
        <aside className="w-72 bg-gray-800/50 p-3 overflow-y-auto border-r border-gray-700">
          <h2 className="text-base font-bold mb-3 flex items-center">
            <Settings className="mr-2" size={16} />
            {t('inputsConfig')}
          </h2>
          
          <div className="space-y-3">
            <div className="bg-gray-800 rounded-lg p-3">
              <h3 className="font-semibold mb-2 text-blue-400 text-sm">{t('materialGeometry')}</h3>
              <div className="space-y-2">
                <div>
                  <label className="block text-xs text-gray-400 mb-1">{t('material')}</label>
                  <select value={material.id} onChange={(e) => setMaterial(MATERIALS_DATABASE.find(m => m.id === e.target.value))} className="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 text-sm">
                    {MATERIALS_DATABASE.map(m => (
                      <option key={m.id} value={m.id}>{m.name[language]}</option>
                    ))}
                  </select>
                </div>
                <div>
                  <label className="block text-xs text-gray-400 mb-1">{t('thickness')}</label>
                  <input type="number" value={thickness} onChange={(e) => setThickness(parseFloat(e.target.value))} className="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 text-sm" />
                </div>
                <div>
                  <label className="block text-xs text-gray-400 mb-1">{t('cutLength')}</label>
                  <input type="number" value={cutLength} onChange={(e) => setCutLength(parseFloat(e.target.value))} className="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 text-sm" />
                </div>
              </div>
            </div>

            <div className="bg-gray-800 rounded-lg p-3">
              <h3 className="font-semibold mb-2 text-green-400 text-sm">{t('machineTooling')}</h3>
              <div className="space-y-2">
                <div>
                  <label className="block text-xs text-gray-400 mb-1">{t('pressure')}</label>
                  <div className="flex items-center space-x-2">
                    <input type="range" value={pressure} onChange={(e) => setPressure(parseFloat(e.target.value))} className="flex-1" min="150" max="600" step="10" />
                    <span className="w-16 text-center bg-gray-700 rounded px-2 py-1 text-xs">{pressure}</span>
                  </div>
                </div>
                <div>
                  <label className="block text-xs text-gray-400 mb-1">{t('abrasiveFlow')}</label>
                  <div className="flex items-center space-x-2">
                    <input type="range" value={abrasiveFlow} onChange={(e) => setAbrasiveFlow(parseFloat(e.target.value))} className="flex-1" min="100" max="800" step="10" />
                    <span className="w-16 text-center bg-gray-700 rounded px-2 py-1 text-xs">{abrasiveFlow}</span>
                  </div>
                </div>
                <div className="grid grid-cols-2 gap-2">
                  <div>
                    <label className="block text-xs text-gray-400 mb-1">{t('orificeId')}</label>
                    <select value={orificeId} onChange={(e) => setOrificeId(parseFloat(e.target.value))} className="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 text-xs">
                      <option value="0.25">0.25</option>
                      <option value="0.30">0.30</option>
                      <option value="0.35">0.35</option>
                    </select>
                  </div>
                  <div>
                    <label className="block text-xs text-gray-400 mb-1">{t('nozzleId')}</label>
                    <select value={nozzleId} onChange={(e) => setNozzleId(parseFloat(e.target.value))} className="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 text-xs">
                      <option value="0.76">0.76</option>
                      <option value="1.02">1.02</option>
                      <option value="1.27">1.27</option>
                    </select>
                  </div>
                </div>
                <div>
                  <label className="block text-xs text-gray-400 mb-1">{t('abrasiveType')}</label>
                  <select value={abrasiveType} onChange={(e) => setAbrasiveType(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 text-xs">
                    <option value="garnet">{t('garnet')}</option>
                    <option value="olivine">{t('olivine')}</option>
                  </select>
                </div>
                {(userLevel === 'manager') && (
                  <div>
                    <label className="block text-xs text-gray-400 mb-1">{t('electricityCost')}</label>
                    <input type="number" value={electricityCost} onChange={(e) => setElectricityCost(parseFloat(e.target.value))} className="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 text-xs" step="0.01" />
                  </div>
                )}
              </div>
            </div>

            <div className="bg-gray-800 rounded-lg p-3">
              <h3 className="font-semibold mb-2 text-purple-400 text-sm">{t('optimizationGoal')}</h3>
              <div>
                <label className="block text-xs text-gray-400 mb-1">{t('tradeoff')}</label>
                <div className="flex items-center space-x-2">
                  <span className="text-xs">{t('eco')}</span>
                  <input type="range" value={optimizationLevel} onChange={(e) => setOptimizationLevel(parseInt(e.target.value))} className="flex-1" min="1" max="5" step="1" />
                  <span className="text-xs">{t('quality')}</span>
                </div>
                <div className="flex justify-between text-xs text-gray-500 mt-1">
                  {[1,2,3,4,5].map(i => <span key={i}>•</span>)}
                </div>
              </div>
              {(userLevel === 'engineer' || userLevel === 'manager') && (
                <div className="mt-2">
                  <label className="block text-xs text-gray-400 mb-1">{t('predictionModel')}</label>
                  <select value={model} onChange={(e) => setModel(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 text-xs">
                    <option value="physical">{t('modelPhysical')}</option>
                    <option value="regression">{t('modelRegression')}</option>
                    <option value="ann">{t('modelAnn')}</option>
                    <option value="gp">{t('modelGP')}</option>
                    <option value="symbolic">{t('modelSymbolic')}</option>
                    <option value="hybrid">{t('modelHybrid')}</option>
                  </select>
                </div>
              )}
            </div>
          </div>
        </aside>

        <section className="flex-1 p-3 overflow-y-auto">
          <div className="space-y-3">
            {results && (
              <>
                <div className="bg-gray-800 rounded-lg p-3">
                  <h3 className="text-base font-bold mb-3 flex items-center">
                    <CheckCircle className="mr-2 text-green-400" size={16} />
                    {t('recommendedParams')}
                  </h3>
                  <div className="grid grid-cols-4 gap-3">
                    <div className="text-center">
                      <div className="text-xs text-gray-400">{t('traverseSpeed')}</div>
                      <div className="text-2xl font-bold text-blue-400">{results.Vpopt}</div>
                      <div className="text-xs text-gray-500">mm/min</div>
                    </div>
                    <div className="text-center">
                      <div className="text-xs text-gray-400">{t('pressure')}</div>
                      <div className="text-2xl font-bold text-green-400">{results.pressure}</div>
                      <div className="text-xs text-gray-500">MPa</div>
                    </div>
                    <div className="text-center">
                      <div className="text-xs text-gray-400">{t('abrasiveFlow')}</div>
                      <div className="text-2xl font-bold text-orange-400">{results.abrasiveFlow}</div>
                      <div className="text-xs text-gray-500">g/min</div>
                    </div>
                    <div className="text-center">
                      <div className="text-xs text-gray-400">{t('limitDepth')}</div>
                      <div className="text-2xl font-bold text-purple-400">{results.Hlim}</div>
                      <div className="text-xs text-gray-500">mm</div>
                    </div>
                  </div>
                </div>

                <div className="bg-gray-800 rounded-lg p-3">
                  <div className="flex justify-between items-center mb-3">
                    <h3 className="text-base font-bold flex items-center">
                      <BarChart3 className="mr-2" size={16} />
                      {t('visualizations')}
                    </h3>
                    <select value={chartType} onChange={(e) => setChartType(e.target.value)} className="bg-gray-700 border border-gray-600 rounded px-2 py-1 text-xs">
                      <option value="roughness">{t('chartRoughness')}</option>
                      <option value="taper">{t('chartTaper')}</option>
                      <option value="forces">{t('chartForces')}</option>
                      <option value="stress">{t('chartStress')}</option>
                    </select>
                  </div>
                  {renderChart()}
                </div>

                <div className="bg-gray-800 rounded-lg p-3">
                  <h3 className="text-base font-bold mb-3">{t('discreteResults')}</h3>
                  <div className="overflow-x-auto">
                    <table className="w-full text-xs">
                      <thead className="bg-gray-700">
                        <tr>
                          <th className="px-3 py-2 text-left">{t('depth')} (mm)</th>
                          <th className="px-3 py-2 text-left">Ra (µm)</th>
                          <th className="px-3 py-2 text-left">Yret (mm)</th>
                          <th className="px-3 py-2 text-left">Taper (°)</th>
                          <th className="px-3 py-2 text-left">Fh (N)</th>
                          <th className="px-3 py-2 text-left">Fv (N)</th>
                        </tr>
                      </thead>
                      <tbody>
                        {results.profile.filter((_, i) => [0, 2, 4, 9, 14, 19].includes(i)).map((p, i) => (
                          <tr key={i} className="border-b border-gray-700">
                            <td className="px-3 py-2">{p.h}</td>
                            <td className="px-3 py-2">{p.Ra}</td>
                            <td className="px-3 py-2">{p.Yret}</td>
                            <td className="px-3 py-2">{p.taper}</td>
                            <td className="px-3 py-2">{p.forces.Fh}</td>
                            <td className="px-3 py-2">{p.forces.Fv}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              </>
            )}
          </div>
        </section>

        <aside className="w-72 bg-gray-800/50 p-3 overflow-y-auto border-l border-gray-700">
          <h2 className="text-base font-bold mb-3 flex items-center">
            <TrendingUp className="mr-2" size={16} />
            {t('analysis')}
          </h2>
          
          <div className="space-y-3">
            {results && (
              <>
                <div className="bg-gray-800 rounded-lg p-3">
                  <h3 className="font-semibold mb-2 text-sm">{t('costBreakdown')}</h3>
                  <ResponsiveContainer width="100%" height={150}>
                    <PieChart>
                      <Pie data={[
                        { name: 'Energy', value: parseFloat(results.costs.energy) },
                        { name: 'Abrasive', value: parseFloat(results.costs.abrasive) },
                        { name: 'Labor', value: parseFloat(results.costs.labor) },
                        { name: 'Tool', value: parseFloat(results.costs.toolWear) }
                      ]} dataKey="value" nameKey="name" cx="50%" cy="50%" outerRadius={50} label>
                        {[0,1,2,3].map((_, i) => (
                          <Cell key={i} fill={['#3B82F6', '#10B981', '#F59E0B', '#EF4444'][i]} />
                        ))}
                      </Pie>
                      <Tooltip contentStyle={{ backgroundColor: '#1F2937', border: '1px solid #374151' }} />
                    </PieChart>
                  </ResponsiveContainer>
                </div>

                {(userLevel === 'engineer' || userLevel === 'manager') && (
                  <>
                    <div className="bg-gray-800 rounded-lg p-3">
                      <h3 className="font-semibold mb-2 text-sm">{t('comparison')}</h3>
                      <select value={comparisonMaterial || ''} onChange={(e) => setComparisonMaterial(e.target.value)} className="w-full bg-gray-700 border border-gray-600 rounded px-2 py-1 text-xs mb-2">
                        <option value="">{t('compareWith')}</option>
                        {MATERIALS_DATABASE.filter(m => m.id !== material.id).map(m => (
                          <option key={m.id} value={m.id}>{m.name[language]}</option>
                        ))}
                      </select>
                      {renderComparison()}
                    </div>

                    <div className="bg-gray-800 rounded-lg p-3">
                      <h3 className="font-semibold mb-2 text-sm">{t('modelDetails')}</h3>
                      <div className="text-xs text-gray-400 space-y-1">
                        <div>Model: <span className="text-white">{model.toUpperCase()}</span></div>
                        <div>Kawj: <span className="text-white">{results.Kawj} mm</span></div>
                        <div>Confidence: <span className="text-green-400">95%</span></div>
                        <div>Accuracy: <span className="text-green-400">±5%</span></div>
                      </div>
                    </div>
                  </>
                )}

                <div className="bg-gray-800 rounded-lg p-3">
                  <h3 className="font-semibold mb-2 text-sm flex items-center">
                    <Sparkles className="mr-1" size={14} />
                    {t('expertAnalysis')}
                  </h3>
                  <button onClick={generateExpertAnalysis} className="w-full bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 py-2 rounded text-xs font-semibold mb-2">
                    {t('generateAnalysis')}
                  </button>
                  {expertAnalysis && (
                    <div className="bg-gray-900 rounded p-2 text-xs text-gray-300 max-h-48 overflow-y-auto whitespace-pre-line">
                      {expertAnalysis}
                    </div>
                  )}
                </div>

                <div className="bg-gray-800 rounded-lg p-3">
                  <h3 className="font-semibold mb-2 text-sm flex items-center">
                    <Download className="mr-1" size={14} />
                    {t('export')}
                  </h3>
                  <div className="grid grid-cols-2 gap-2">
                    <button onClick={() => exportResults('csv')} className="bg-green-600 hover:bg-green-700 px-3 py-2 rounded text-xs">CSV</button>
                    <button onClick={() => exportResults('json')} className="bg-blue-600 hover:bg-blue-700 px-3 py-2 rounded text-xs">JSON</button>
                  </div>
                </div>

                <button onClick={() => setShowVR(true)} className="w-full bg-gradient-to-r from-cyan-600 to-blue-600 hover:from-cyan-700 hover:to-blue-700 px-3 py-3 rounded-lg text-sm font-semibold flex items-center justify-center space-x-2">
                  <Eye size={16} />
                  <span>{t('vrSimulation')}</span>
                </button>
              </>
            )}
          </div>
        </aside>
      </div>

      {/* AI Chat Button */}
      <button onClick={() => setShowChat(!showChat)} className="fixed bottom-4 right-4 bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 text-white rounded-full p-3 shadow-2xl z-50 flex items-center space-x-2">
        <MessageSquare size={20} />
        <span className="font-semibold text-sm">{t('aiAssistant')}</span>
      </button>

      {/* AI Chat Window */}
      {showChat && (
        <div className="fixed bottom-20 right-4 w-96 h-[500px] bg-gray-800 rounded-lg shadow-2xl border border-gray-700 flex flex-col z-50">
          <div className="bg-gradient-to-r from-purple-600 to-indigo-600 p-3 rounded-t-lg flex justify-between items-center">
            <div className="flex items-center space-x-2">
              <div className="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>
              <h3 className="font-bold text-sm">{t('aiAssistant')}</h3>
            </div>
            <button onClick={() => setShowChat(false)} className="text-white hover:text-gray-200 text-xl">&times;</button>
          </div>
          
          <div className="flex-1 overflow-y-auto p-3 space-y-2 bg-gray-900">
            {chatMessages.map((msg, i) => (
              <div key={i} className={`flex ${msg.bot ? 'justify-start' : 'justify-end'}`}>
                <div className={`max-w-[85%] rounded-lg p-2 text-xs ${msg.bot ? 'bg-gray-700' : 'bg-gradient-to-r from-purple-600 to-indigo-600'}`}>
                  <p className="whitespace-pre-line">{msg.text}</p>
                </div>
              </div>
            ))}
          </div>
          
          <div className="p-3 bg-gray-800 rounded-b-lg border-t border-gray-700">
            <div className="flex space-x-2">
              <input 
                type="text" 
                value={chatInput} 
                onChange={(e) => setChatInput(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
                placeholder="Ask about AWJ..."
                className="flex-1 bg-gray-700 text-white rounded-lg px-3 py-2 text-xs"
              />
              <button onClick={handleSendMessage} className="bg-purple-600 hover:bg-purple-700 rounded-lg px-3 py-2">
                <Sparkles size={16} />
              </button>
            </div>
            <div className="mt-2 flex space-x-1 flex-wrap gap-1">
              <button onClick={() => { setChatInput('What is Yret?'); handleSendMessage(); }} className="text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded-full">Yret?</button>
              <button onClick={() => { setChatInput('Explain Ra'); handleSendMessage(); }} className="text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded-full">Ra?</button>
              <button onClick={() => { setChatInput('Improve quality'); handleSendMessage(); }} className="text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded-full">Quality?</button>
            </div>
          </div>
        </div>
      )}

      {/* VR Modal */}
      {showVR && (
        <div className="fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center p-4">
          <div className="bg-gray-800 border border-gray-700 rounded-lg shadow-2xl w-full max-w-5xl h-5/6 flex flex-col">
            <div className="bg-gradient-to-r from-cyan-600 to-blue-600 p-3 rounded-t-lg flex justify-between items-center">
              <h2 className="text-lg font-bold">{t('vrSimulation')}</h2>
              <div className="flex space-x-2">
                <button onClick={() => setVRScene('simulation')} className={`px-3 py-1 rounded text-xs ${vrScene === 'simulation' ? 'bg-blue-700' : 'bg-blue-600 hover:bg-blue-700'}`}>
                  {t('cutSimulation')}
                </button>
                <button onClick={() => setVRScene('params')} className={`px-3 py-1 rounded text-xs ${vrScene === 'params' ? 'bg-blue-700' : 'bg-blue-600 hover:bg-blue-700'}`}>
                  {t('paramAnalysis')}
                </button>
                <button onClick={() => setVRScene('data')} className={`px-3 py-1 rounded text-xs ${vrScene === 'data' ? 'bg-blue-700' : 'bg-blue-600 hover:bg-blue-700'}`}>
                  {t('dataViz')}
                </button>
                <button onClick={() => setShowVR(false)} className="text-white hover:text-gray-200 text-2xl ml-2">&times;</button>
              </div>
            </div>
            
            <div className="flex-1 bg-gray-900 rounded-b-lg overflow-hidden flex items-center justify-center">
              <div className="text-center text-gray-400">
                <Box size={48} className="mx-auto mb-4 opacity-50" />
                <p className="text-sm">3D VR Simulation</p>
                <p className="text-xs mt-2">{vrScene === 'simulation' ? 'AWJ Cutting Process Animation' : vrScene === 'params' ? 'Parameter Visualization in 3D' : 'Data Charts in 3D Space'}</p>
                <p className="text-xs text-gray-500 mt-4">Scene: {vrScene}</p>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default AWJCalculator;